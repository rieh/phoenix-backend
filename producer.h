#ifndef PRODUCER_H
#define PRODUCER_H

#include "backendcommon.h"

/*
 * Functionality and structures common to all producers.
 *
 * In your subclass (mandatory):
 * class ProducerSubclass : public QObject, public Producer {
 *     signals:
 *         PRODUCER_SIGNALS
 *         void anyOtherSignals();
 * };
 *
 * To connect to these signals:
 * connect( dynamic_cast<QObject *>( ConsumerSubclassPtr ), SIGNAL( producerSignal ),
 *          dynamic_cast<QObject *>( ProducerSubclassPtr ), SLOT( consumerSlot ) );
 *
 * Thanks to peppe and thiago from #Qt on Freenode for the idea
 */

// In order to properly declare the signals in your subclass, simply use this macro under "signals"
// Documented below
#define PRODUCER_SIGNALS \
    void producerFormat( ProducerFormat format ); \
    void producerData( QString type, QMutex *producerMutex, void *data, size_t bytes );


// Type of video output (for use by video consumers)
enum VideoRendererType {

    // Video is generated by the CPU and lives in RAM
    SOFTWARERENDER = 0,

    // Video is generated by the GPU and lives in an FBO
    HARDWARERENDER

};

// Information for the consumer from the producer
struct ProducerFormat {

    ProducerFormat();
    ~ProducerFormat();

    // "libretro", etc.
    QString producerType;

    // Audio

    QAudioFormat audioFormat;

    // If audio data is sent at a regular rate, but the amount is too much/insufficient to keep the buffer from
    // over/underflowing, stretch the incoming audio data by this factor to compensate
    // In Libretro cores, this factor compensates for the emulation rate differing from the console's native framerate
    // if using VSync, for example
    qreal audioRatio;

    // Video

    size_t videoBytesPerLine;
    VideoRendererType videoMode;
    qreal videoFramerate;
    QImage::Format videoPixelFormat;
    QSize videoSize;

};
Q_DECLARE_METATYPE( ProducerFormat )

class Producer {

    public:
        Producer();
        ~Producer();

    signals:
        // Format information for consumers.
        // void producerFormat( ProducerFormat format );

        // Data for consumers. Pointers will be valid for the lifetime of the producer
        // void producerData( QString type, QMutex *producerMutex, void *data, size_t bytes );

    public slots:

    protected:
        QMutex producerMutex;

};
Q_DECLARE_METATYPE( size_t )

#endif // PRODUCER_H
